---
alwaysApply: true
---

# 规则冲突管理

> 管理项目规则文件与规则库之间的冲突检测和处理逻辑，保护用户自定义规则，智能合并更新

## 核心原则

### 规则文件分类

项目 `.cursor/rules/` 目录中的规则文件分为三类：

1. **本项目规则文件**：从规则库导入的项目类型规则文件（如 `flutter-rules.mdc`、`android-rules.mdc`）
2. **通用规则文件**：从规则库导入的通用规则文件（如 `user-base-rule.mdc`、`git-automation.mdc`）
3. **用户自定义规则文件**：不属于规则库的文件，是用户自定义的规则（如 `custom-rules.mdc`、`team-rules.mdc`）

### 处理原则

- **本项目规则文件**：可能被更新，需要检测是否被用户修改
- **通用规则文件**：可能被更新，需要检测是否被用户修改
- **用户自定义规则文件**：**绝对不触碰**，完全保留

## 冲突检测流程

### 第一步：识别现有规则文件

在导入或更新规则前，必须先扫描 `.cursor/rules/` 目录：

1. **列出所有 `.mdc` 文件**
   - 获取目录中所有 `.mdc` 文件的文件名和路径

2. **识别规则文件类型**
   - 根据文件名判断规则文件类型：
     * **本项目规则**：匹配规则库中的项目规则文件名（如 `flutter-rules.mdc`、`android-rules.mdc` 等）
     * **通用规则**：匹配规则库中的通用规则文件名（如 `user-base-rule.mdc`、`git-automation.mdc` 等）
     * **用户自定义规则**：不匹配任何规则库文件名的规则文件

3. **分类统计**
   ```
   本项目规则文件：[
     { 文件名: "flutter-rules.mdc", 路径: "...", 是否被修改: 待检测 }
   ]
   
   通用规则文件：[
     { 文件名: "user-base-rule.mdc", 路径: "...", 是否被修改: 待检测 }
   ]
   
   用户自定义规则文件：[
     { 文件名: "custom-rules.mdc", 路径: "..." }
   ]
   ```

### 第二步：检测用户自定义规则（保护机制）

**重要原则：用户自定义规则文件绝对不触碰！**

1. **识别用户自定义规则**
   - 文件名列在"用户自定义规则文件"列表中
   - 这些文件不会被覆盖、删除或修改

2. **保护机制**
   - 导入新规则时，跳过这些文件
   - 更新规则时，跳过这些文件
   - 在日志中明确说明："已跳过用户自定义规则文件：xxx.mdc"

### 第三步：检测规则文件是否被修改

对于"本项目规则文件"和"通用规则文件"，需要检测是否被用户修改：

#### 方法 1：内容哈希比较（推荐）

1. **计算规则库中文件的哈希值**
   - 从规则库（本地缓存或 GitHub）读取规则文件的原始内容
   - 计算原始内容的哈希值（MD5 或 SHA256）

2. **计算项目中文件的哈希值**
   - 读取项目中现有规则文件的内容
   - 计算现有内容的哈希值

3. **比较哈希值**
   - 如果哈希值相同 → 文件未被修改，可以安全覆盖
   - 如果哈希值不同 → 文件已被修改，需要用户确认

#### 方法 2：内容对比（备用方案）

如果无法获取哈希值，使用内容对比：

1. **读取规则库中的原始内容**
2. **读取项目中的现有内容**
3. **进行内容对比**
   - 如果内容完全相同 → 文件未被修改
   - 如果内容不同 → 文件已被修改

### 第四步：生成冲突报告

检测完成后，生成详细的冲突报告：

```markdown
## 📋 规则冲突检测报告

### 用户自定义规则文件（将保留）
- ✅ `custom-rules.mdc` - 用户自定义规则，不会触碰
- ✅ `team-rules.mdc` - 用户自定义规则，不会触碰

### 本项目规则文件

#### 未修改的文件（可以直接更新）
- ✅ `flutter-rules.mdc` - 未修改，可以直接覆盖更新

#### 已修改的文件（需要确认）
- ⚠️ `android-rules.mdc` - **检测到用户修改**，需要确认处理方式

### 通用规则文件

#### 未修改的文件（可以直接更新）
- ✅ `git-automation.mdc` - 未修改，可以直接覆盖更新

#### 已修改的文件（需要确认）
- ⚠️ `user-base-rule.mdc` - **检测到用户修改**，需要确认处理方式

---

### 处理建议
[说明推荐的处理方式]
```

## 冲突处理方案

### 场景 1：文件未被修改（可以安全更新）

**处理方式**：直接覆盖更新

- 不需要询问用户
- 直接从规则库拉取最新版本覆盖
- 记录日志："已更新规则文件：xxx.mdc"

### 场景 2：文件已被修改（需要用户确认）

**必须询问用户**，提供三种处理选项：

#### 选项 A：覆盖还原（恢复到规则库版本）

- **说明**：放弃用户的修改，恢复到规则库中的最新版本
- **适用场景**：用户不需要保留修改，想使用最新规则
- **操作**：直接覆盖文件

#### 选项 B：保留用户版本（不更新）

- **说明**：保留用户的修改，不进行更新
- **适用场景**：用户的修改很重要，不想丢失
- **操作**：跳过该文件，不更新

#### 选项 C：智能合并（推荐）

- **说明**：在用户修改的基础上，合并规则库的新内容
- **适用场景**：既想保留用户修改，又想获取规则库更新
- **操作**：AI 智能合并两个版本的内容

### 场景 3：用户自定义规则文件

**处理方式**：绝对不触碰

- 不询问用户
- 不覆盖、不删除、不修改
- 记录日志："已跳过用户自定义规则文件：xxx.mdc"

## 智能合并策略

### 合并原则

当用户选择"智能合并"时，AI 需要智能合并两个版本：

1. **保留用户新增内容**
   - 用户添加的新章节、新规则
   - 用户添加的注释和说明

2. **保留用户修改内容**
   - 用户修改的配置值
   - 用户自定义的规范

3. **合并规则库更新**
   - 规则库中新增的内容
   - 规则库中更新的内容
   - 规则库中修复的问题

4. **处理冲突**
   - 如果同一位置都有修改，保留用户的修改（用户优先级更高）
   - 如果规则库新增了章节，合并到用户版本中
   - 生成合并报告，说明合并了哪些内容

### 合并流程

1. **读取两个版本**
   - 读取规则库中的最新版本
   - 读取项目中的用户版本

2. **分析差异**
   - 识别新增内容（规则库新增、用户新增）
   - 识别修改内容（规则库修改、用户修改）
   - 识别冲突内容（同一位置都有修改）

3. **生成合并版本**
   - 以用户版本为基础
   - 合并规则库的新增内容
   - 处理冲突（优先保留用户修改）
   - 保持文件结构和格式

4. **生成合并报告**

```markdown
## 🔄 规则合并报告

### 合并文件：`flutter-rules.mdc`

#### 保留的用户修改
- ✅ 用户自定义的代码风格规范（第 15-20 行）
- ✅ 用户添加的项目特定说明（第 50 行）

#### 合并的规则库更新
- ✅ 新增了"性能优化"章节
- ✅ 更新了"依赖管理"章节的最新实践
- ✅ 修复了"错误处理"章节的说明

#### 冲突处理
- ⚠️ 同一位置的修改：保留了用户的修改（用户优先级更高）

### 合并后的文件已保存
```

5. **展示合并报告并等待确认**
   - 展示合并报告给用户
   - 用户确认后才保存合并后的文件
   - 如果用户不满意，可以重新选择处理方式

## 用户交互流程

### 导入/更新规则时的完整流程

1. **扫描现有规则文件**
   - 识别所有 `.mdc` 文件
   - 分类为：本项目规则、通用规则、用户自定义规则

2. **检测用户自定义规则**
   - 识别用户自定义规则文件
   - 明确说明这些文件不会被触碰

3. **检测修改状态**
   - 对比规则库版本和项目版本
   - 识别哪些文件被修改了

4. **生成冲突报告**
   - 展示详细的冲突检测报告
   - 说明每个文件的状态

5. **处理未修改的文件**
   - 直接更新未修改的文件
   - 记录日志

6. **询问用户处理已修改的文件**
   - 展示已修改的文件列表
   - 为每个文件提供三种处理选项：
     * 覆盖还原
     * 保留用户版本
     * 智能合并

7. **执行用户选择**
   - 根据用户选择执行相应操作
   - 如果选择合并，进行智能合并并展示报告

8. **完成提示**
   - 展示最终的处理结果
   - 说明哪些文件已更新、哪些已保留、哪些已合并

## 规则文件名识别规则

### 本项目规则文件名识别

根据 `rules-management/project-rules-auto-management.mdc` 中的命名映射规则识别：

- `flutter-rules.mdc` → 对应规则库中的 `flutter-project.mdc`
- `android-rules.mdc` → 对应规则库中的 `android-project.mdc`
- `python-rules.mdc` → 对应规则库中的 `python-project.mdc`
- 其他项目规则文件...

### 通用规则文件名识别

**⚠️ 重要：必须使用 `list_dir` 动态获取 `common-project-rules/` 目录下的所有文件名**

根据规则库中 `common-project-rules/` 目录下的文件名识别：

**识别方式**：
1. **使用 `list_dir` 工具扫描规则库的 `common-project-rules/` 目录**，获取所有 `.mdc` 文件名
2. **项目中的规则文件**如果文件名匹配 `list_dir` 获取的任意文件名，则识别为通用规则文件
3. **禁止使用硬编码的文件名列表**，必须动态获取

**示例**（仅供参考，实际必须动态获取）：
- `user-base-rule.mdc` → 对应规则库中的 `common-project-rules/user-base-rule.mdc`
- `git-automation.mdc` → 对应规则库中的 `common-project-rules/git-automation.mdc`
- `batch-file-operations.mdc` → 对应规则库中的 `common-project-rules/batch-file-operations.mdc`
- `hardware-limitations.mdc` → 对应规则库中的 `common-project-rules/hardware-limitations.mdc`
- `documentation-format.mdc` → 对应规则库中的 `common-project-rules/documentation-format.mdc`
- `ui-design-reconstruction.mdc` → 对应规则库中的 `common-project-rules/ui-design-reconstruction.mdc`
- 以及其他所有 `list_dir` 获取的文件名...

**排除**：
- `project-rules-auto-management.mdc` → 对应规则库中的 `rules-management/project-rules-auto-management.mdc`（不导入到用户项目，属于规则管理文件）

### 用户自定义规则识别

**不匹配任何规则库文件名的规则文件都是用户自定义规则**，包括：

- 文件名不匹配任何规则库文件的规则
- 文件名包含"custom"、"team"、"personal"等自定义标识的规则
- 文件名包含项目特定标识的规则

## 注意事项

1. **用户自定义规则优先级最高**
   - 绝对不触碰用户自定义规则文件
   - 这是不可违反的原则

2. **用户修改的规则优先保留**
   - 智能合并时，用户修改优先级高于规则库更新
   - 除非用户明确选择覆盖还原

3. **合并需要用户确认**
   - 智能合并后，必须展示合并报告
   - 等待用户确认后才保存

4. **清晰的日志记录**
   - 所有操作都要记录清晰的日志
   - 让用户知道每个文件是如何处理的

5. **错误处理**
   - 如果检测或合并失败，给出明确的错误提示
   - 提供回滚机制（如果可能）